/**
  * addExecRight v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t(require("node:fs"),require("node:child_process")):"function"==typeof define&&define.amd?define(["node:fs","node:child_process"],t):(e="undefined"!=typeof globalThis?globalThis:e||self)["add-exec-right"]=t(e.node_fs,e.node_child_process)}(this,(function(e,t){"use strict";
/**
    * runBash v0.0.3
    * (c) 2018-2022 ymc
    * @license MIT
    */function n(e){return e.split(/\r?\n/).map((e=>e.trim())).filter((e=>e)).join("\n")}const i=(e,i,s)=>new Promise(((o,a)=>{s||(s=i,i=e,e="");const r=((e,t=" ")=>Array.isArray(e)?e.join(t):e)(i);(s.exec?s.exec:t.exec)(`${e=e?`${e} ${r}`:`${r}`}`,s,((e,t,i)=>{const{fixUnreadbleCode:r}=s;if(r){const{iconvDesEncoding:e,iconvSrcEncoding:n}=s;t&&(t=r(t,e,n)),i&&(i=r(i,e,n))}e&&s.exitWhenErr&&a(e),s.noTrimOut||(t=n(t),i=n(i)),s.rejectStderr&&(i&&a(e),o(t)),o({stdout:t,stderr:i})}))})),s={exec:t.exec},{log:o}=console;class a{constructor(e){this.init(e)}init(e){return this._max=e,this._count=0,this._taskQueue=[],this._debug=!1,this._cb=null,this}call(e,...t){return new Promise(((n,i)=>{const s=this._createTask(e,t,n,i);this._count>=this._max?this._taskQueue.push(s):s()}))}_createTask(e,t,n,i){return()=>{e(...t).then(n).catch(i).finally((()=>{this._next()})),this._nextTick()}}_next(){if(this._count-=1,this._taskQueue.length){this._taskQueue.shift()()}else this._debug&&o("task count = ",this._count),this._cb&&this._cb()}_nextTick(){this._count+=1,this._debug&&o("task count = ",this._count)}}new a;
/**
    * kindOf v1.0.0
    * (c) 2018-2022 ymc
    * @license MIT
    */
const{toString:r}=Object.prototype,c=(l=Object.create(null),e=>{const t=r.call(e);return l[t]||(l[t]=t.slice(8,-1).toLowerCase())});var l;const{log:d}=console;function u(e){return function(...t){e&&d(...t)}}
/**
    * streamIo v1.0.0
    * (c) 2018-2022 ymc
    * @license MIT
    */
/**
    * textStreamIo v1.0.0
    * (c) 2018-2022 ymc
    * @license MIT
    */
class f{constructor(e="CHANGELO.md"){this.init(e)}async read(t=""){const{file:n}=this;let i,s;try{i=e.createReadStream(n.name),s=await(o=i,new Promise(((e,t)=>{let n="";o.on("data",(e=>{n+=e.toString()})).on("end",(()=>{e(n)})).on("error",t)})))}catch(e){s=t}var o;return n.data=s,s}async write(t){const{file:n,option:i}=this;let s,o,a;switch(s=e.createWriteStream(n.name),o=n.data,i.writemode){case"override":default:a=`${t}`;break;case"append":a=`${o}\n${t}`;break;case"head":a=`${t}\n${o}`}n.data=a,await function({stream:e,data:t}){return new Promise(((n,i)=>{e.write(t,"utf-8"),e.end(),e.on("finish",(()=>{n(t)})).on("error",i)}))}({stream:s,data:a})}init(e="CHANGELO.md",t=""){return this.file={name:e,data:t},this.option={},this}new(...e){return new f(...e)}}new f;const h=u(!0);return async function(t={}){const n={binPath:"bin",ext:".js,.sh",...t},o=u(n.logInfo);u(n.logTask)("[task] add exec rights to files"),o("[info] read file list");const r=n.binPath;let l=e.readdirSync(r).map((e=>`${r}/${e}`)).filter((t=>e.statSync(t).isFile()));if(o("[info] filter file list when ext passed"),n.ext){const{ext:e}=n,t=e.split(",").map((e=>new RegExp(`${e}$`)));l=l.filter((e=>t.some((t=>t.test(e)))))}const d=e=>async()=>{let t;e.onFileHead&&await async function(e={}){const t={fileHead:"#!/usr/bin/env node",...e};let n,i;const s=new f;s.init(t.loc),n=await s.read(""),n=n.split(/\r?\n/),[i]=n,i&&!/^#!/i.test(i)&&("del"===t.action?n.shift():n.unshift(t.fileHead));n=n.join("\n"),s.init(t.loc),await s.write(n)}({loc:e.file,...e.fileHead?{fileHead:e.fileHead}:{}});let n=`chmod +x ${e.file}`;return o(`[info] run: ${n}`),t=await i(n,s),e.updateByGit&&(n=`git update-index --chmod=+x ${e.file}`,o(`[info] run: ${n}`),t=await i(n,s)),t};let _;
/**
    * promiseAll v1.0.0
    * (c) 2018-2022 ymc
    * @license MIT
    */
var m,w;let p;o("[info] gen task handle"),_=l.map((e=>d({...n,file:e}))),await(m=_,w=3,new Promise(((e,t)=>{const n=w||m.length,i=new a(n),s=[],o=t=>{let n=m[t];return"asyncfunction"===c(n)?n=n():"function"===c(n)&&(n=Promise.resolve(n())),n.then((e=>{i._debug?s[t]={index:t,data:e,state:"ok"}:s[t]=e}),(e=>{i._debug?s[t]={index:t,state:"no",error:e}:s[t]=e})).finally((()=>{i._cb=()=>{
//! this._taskQueue.length && this._count===0
0===i._count&&e(s)}}))};for(let e=0;e<m.length;e+=1)i.call(o,e)}))),n.verbose||(p=await i(`ls ${r} -l`,s),h(p))}}));
