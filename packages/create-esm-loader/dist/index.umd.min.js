/**
  * createEsmLoader v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */
!function(t,o){"object"==typeof exports&&"undefined"!=typeof module?module.exports=o():"function"==typeof define&&define.amd?define(o):(t="undefined"!=typeof globalThis?globalThis:t||self)["create-esm-loader"]=o()}(this,(function(){"use strict";
/**
    * compareVersion v1.0.0
    * (c) 2018-2022 ymc
    * @license MIT
    */function t(t,o){const n=`${o}`;let r=[];if(t){let t=n.split("-")[1];r=n.split("-")[0].split("."),t=t.split("."),r=r.concat(t)}else r=n.split(".");return r}function o(t){return t.map((t=>Number.isNaN(t)?t:parseInt(t)))}function n(n,r){const s=`${n}`,e=`${r}`,i=s.indexOf("-")>-1,a=e.indexOf("-")>-1;let c=t(i,s),f=t(a,e);c=o(c),f=o(f);const u=Math.max(c.length,f.length);for(let t=0;t<u;t+=1){if(3===t&&(void 0===c[t]||void 0===f[t])){if(void 0===c[t]&&Number.isNaN(f[t]))return 1;if(Number.isNaN(c[t])&&void 0===f[t])return-1}if(void 0===c[t])return-1;if(void 0===f[t])return 1;if(c[t]>f[t])return 1;if(c[t]<f[t])return-1}return 0}function r(t){return async function(...o){return{shortCircuit:!0,...await t(...o)}}}function s(t){return t?Array.isArray(t)?t.flat(1/0):[t]:[]}function e(t,o){return Object.prototype.hasOwnProperty.call(t,o)}function i(){}function a(t){return"string"==typeof t?{loader:t,options:{}}:e(t,"loader")?{loader:t.loader,options:{...t.options}}:e(t,"hooks")?t:{hooks:t,options:{}}}const c=["resolve","format","fetch","transform"];function f(){return function(t){return t.reduce(((t,o)=>(t[o]=[],t)),{})}(c)}class u{constructor(t={},o={}){e(t,"loaders")&&({loaders:t,options:o={}}=t),this.options=o,this.stack=null;const n=new Promise((async o=>{this.stack=await this.buildStack(t),o(this)}));this.ready=()=>n}async handleStack(t,o,n,r){const s=this.stack[t]||[],e={...this.options};for(const{fn:t,options:r}of s){const s={...e,...r,...n},i=await t(o,s);if(i)return i}return r(o,n,r)}hooks(){const t=t=>(...o)=>this.handleStack(t,...o),o=r(t("resolve")),s=t("format"),e=t("fetch"),a=async(t,o,n)=>{const r=this.stack.transform||[],s={...this.options};let e=t,i=!0;for(const{fn:t,options:n}of r){const r={...s,...n,...o},a=await t(e,r);(a||"string"==typeof a)&&(i=!1,e="string"==typeof a?a:a.source)}return i?n(t,o,n):{source:e}};if(function(t,o){const r=/=|>|</,s=o.match(r);let e,i;return s?([e]=s,[,i]=o.split(r)):i=o,"<"===e?-1===n(t,i):"="===e?0===n(t,i):">"===e?1===n(t,i):n(t,i)>=0}(process.version,"<16.12.0"))return{resolve:o,getFormat:s,getSource:e,transformSource:a};return{resolve:o,load:r((async(t,o,n)=>{const r=(t={})=>t.format;let{format:c=await s(t,o,i).then(r)}=o;const{source:f}=await e(t,o,(async(t,o)=>{const r=await n(t,{format:c});return c||(c=r.format),r})),u=await a(f,{url:t,format:c},(t=>({source:t})));return{format:c,source:u.source}}))}}async buildStack(t){const o=s(t).flat(1/0),n=[],r=f();for(const t of o){const o=a(t);if("string"!=typeof o.loader)this.fill(o,r);else{const t=f();for(const o of c){r[o].push(t[o])}n.push((async()=>{const n=a({hooks:(await import(o.loader)).default,options:o.options});this.fill(n,t)})())}}await Promise.all(n);for(const t of c)r[t]=r[t].flat(1/0);return r}fill(t,o){const{hooks:n,options:r}=t;for(const t of c){const e=o[t],i=s(n[t]);for(const t of i)e.push({fn:t,options:r})}}}return async function(...t){return(await new u(...t).ready()).hooks()}}));
