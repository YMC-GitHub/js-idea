/**
  * depParse v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */
"use strict";var t=require("node:fs");
/**
  * streamIo v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */
/**
  * textStreamIo v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */
class e{constructor(t="CHANGELO.md"){this.init(t)}async read(e=""){const{file:i}=this;let n,s;try{n=t.createReadStream(i.name),s=await(r=n,new Promise(((t,e)=>{let i="";r.on("data",(t=>{i+=t.toString()})).on("end",(()=>{t(i)})).on("error",e)})))}catch(t){s=e}var r;return i.data=s,s}async write(e){const{file:i,option:n}=this;let s,r,o;switch(s=t.createWriteStream(i.name),r=i.data,n.writemode){case"override":default:o=`${e}`;break;case"append":o=`${r}\n${e}`;break;case"head":o=`${e}\n${r}`}i.data=o,await function({stream:t,data:e}){return new Promise(((i,n)=>{t.write(e,"utf-8"),t.end(),t.on("finish",(()=>{i(e)})).on("error",n)}))}({stream:s,data:o})}init(t="CHANGELO.md",e=""){return this.file={name:t,data:e},this.option={},this}new(...t){return new e(...t)}}const i=new e;function n(...t){return[...t].map((t=>t.split(/\/?\\|\//))).flat(1/0).filter((t=>t)).join(n.sep?n.sep:"/")}function s(t={}){let e={};return Object.keys(t).forEach((i=>{void 0!==t[i]&&(e[i]=t[i])})),e}module.exports=class{constructor(){this.init()}init(){this.option={},this.filetext="",this.matchs=[],this.inLibDeps=[],this.outlibDeps=[],this.alldeps=[],this.deptree={},this.option.inlibdepReg=[/^\./,/@src/],this.option.parsetasks=["in","out"],this.option.nodedeps=["fs","path","os"]}async read(t){return i.init(t),this.filetext=await i.read(),this}delComment(){let{option:t,filetext:e}=this;const{commentReg:i,ignoreComment:n}=t;return e=function(t={}){const e={text:"",ignoreComment:!0,commentReg:[/\/\/.*/gi,/(\/)([*])+(.|\n)+?(\2\1)/gi],...t};let{text:i,commentReg:n}=e;return e.ignoreComment&&n.forEach((t=>{i=i.replace(t,"")})),i}(s({text:e,commentReg:i,ignoreComment:n})),this.filetext=e,this}getMatchs(){const{option:t,filetext:e}=this,i=function(t={}){const e={text:"",requireReg:[/require\(.*\)/gi,/from +("|').*("|')/gi,/import +("|').*("|')/gi],...t},{requireReg:i,text:n}=e;let s;return s=i.map((t=>{let e;return e=n.match(t),e})),s=s.filter((t=>t)),s=s.flat(1),s=[...new Set(s)],s=s.map((t=>{const e="";let n=t;return n.match(i[0])?n=n.replace(/require\(/,e).replace(/\)/,e):n.match(i[1])?n=n.replace(/from +/,e):n.match(i[2])&&(n=n.replace(/import +/,e)),n=n.replace(/^("|')/,e).replace(/("|')$/,e),n})),s=s.map((t=>{let e=1,i=t;return i.match(/^@/)&&(e+=1),i=i.split(/\//).slice(0,e).join("/"),i})),s}({text:e,...t});return this.matchs=i,i}getInLibDeps(){const{option:t,matchs:e}=this,{inlibdepReg:i}=t,n=function(t={}){const e={data:[""],localDepReg:[/^\./,/@src/],...t},{localDepReg:i,data:n}=e;let s;return s=n.filter((t=>i.some((e=>e.test(t))))),s}(s({data:e,localDepReg:i}));return this.inLibDeps=n,n}getOutlibDes(){const{option:t,matchs:e}=this,{inlibdepReg:i,nodedeps:n}=t,r=function(t={}){const e={localDep:[""],builintDep:[""],disableLocalDepReg:!1,...t},{data:i,localDep:n,localDepReg:s,builintDep:r}=e;let o;return o=[...i],e.disableLocalDepReg||(o=o.filter((t=>!s.some((e=>e.test(t)))))),n&&(o=a(o,n)),r&&(o=a(o,r)),o;function a(t,e){return function(t,e){return t.filter((t=>!e.some((e=>t===e))))}(t,e.filter((t=>"string"==typeof t)))}}(s({data:e,localDepReg:i,builintDep:n}));return this.outlibDeps=r,this}resolveInLibDeps(t){let e=this.inLibDeps;e=function(t={}){const e={data:[""],skipResolveReg:[/^@private-pkgs/,/^@/],...t},{skipResolveReg:i,fileloc:s}=e;let r=[...e.data];return r=r.map((t=>{if(i.some((e=>e.test(t))))return t;let e=n(function(t,e="/"){const i=t.split(/\/?\\|\//);return i.slice(0,i.length-1).join(e)}(s),t);return e=e.replace(/\\/gi,"/"),e})),r}({data:e,fileloc:t}),this.inLibDeps=e}async parse(t){const{option:e}=this,{parsetasks:i}=e;await this.read(t),this.delComment(),this.getMatchs(),i.includes("in")&&(this.getInLibDeps(),this.resolveInLibDeps(t)),i.includes("out")&&this.getOutlibDes();const{inLibDeps:n,outlibDeps:s}=this;return this.alldeps=[...n,...s],this.alldeps}};
