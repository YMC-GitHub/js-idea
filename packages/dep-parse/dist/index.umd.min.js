/**
  * depParse v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t(require("node:fs")):"function"==typeof define&&define.amd?define(["node:fs"],t):(e="undefined"!=typeof globalThis?globalThis:e||self)["dep-parse"]=t(e.node_fs)}(this,(function(e){"use strict";
/**
    * streamIo v1.0.0
    * (c) 2018-2022 ymc
    * @license MIT
    */
/**
    * textStreamIo v1.0.0
    * (c) 2018-2022 ymc
    * @license MIT
    */
class t{constructor(e="CHANGELO.md"){this.init(e)}async read(t=""){const{file:i}=this;let n,s;try{n=e.createReadStream(i.name),s=await(o=n,new Promise(((e,t)=>{let i="";o.on("data",(e=>{i+=e.toString()})).on("end",(()=>{e(i)})).on("error",t)})))}catch(e){s=t}var o;return i.data=s,s}async write(t){const{file:i,option:n}=this;let s,o,r;switch(s=e.createWriteStream(i.name),o=i.data,n.writemode){case"override":default:r=`${t}`;break;case"append":r=`${o}\n${t}`;break;case"head":r=`${t}\n${o}`}i.data=r,await function({stream:e,data:t}){return new Promise(((i,n)=>{e.write(t,"utf-8"),e.end(),e.on("finish",(()=>{i(t)})).on("error",n)}))}({stream:s,data:r})}init(e="CHANGELO.md",t=""){return this.file={name:e,data:t},this.option={},this}new(...e){return new t(...e)}}const i=new t;function n(...e){return[...e].map((e=>e.split(/\/?\\|\//))).flat(1/0).filter((e=>e)).join(n.sep?n.sep:"/")}function s(e={}){let t={};return Object.keys(e).forEach((i=>{void 0!==e[i]&&(t[i]=e[i])})),t}return class{constructor(){this.init()}init(){this.option={},this.filetext="",this.matchs=[],this.inLibDeps=[],this.outlibDeps=[],this.alldeps=[],this.deptree={},this.option.inlibdepReg=[/^\./,/@src/],this.option.parsetasks=["in","out"],this.option.nodedeps=["fs","path","os"]}async read(e){return i.init(e),this.filetext=await i.read(),this}delComment(){let{option:e,filetext:t}=this;const{commentReg:i,ignoreComment:n}=e;return t=function(e={}){const t={text:"",ignoreComment:!0,commentReg:[/\/\/.*/gi,/(\/)([*])+(.|\n)+?(\2\1)/gi],...e};let{text:i,commentReg:n}=t;return t.ignoreComment&&n.forEach((e=>{i=i.replace(e,"")})),i}(s({text:t,commentReg:i,ignoreComment:n})),this.filetext=t,this}getMatchs(){const{option:e,filetext:t}=this,i=function(e={}){const t={text:"",requireReg:[/require\(.*\)/gi,/from +("|').*("|')/gi,/import +("|').*("|')/gi],...e},{requireReg:i,text:n}=t;let s;return s=i.map((e=>{let t;return t=n.match(e),t})),s=s.filter((e=>e)),s=s.flat(1),s=[...new Set(s)],s=s.map((e=>{const t="";let n=e;return n.match(i[0])?n=n.replace(/require\(/,t).replace(/\)/,t):n.match(i[1])?n=n.replace(/from +/,t):n.match(i[2])&&(n=n.replace(/import +/,t)),n=n.replace(/^("|')/,t).replace(/("|')$/,t),n})),s=s.map((e=>{let t=1,i=e;return i.match(/^@/)&&(t+=1),i=i.split(/\//).slice(0,t).join("/"),i})),s}({text:t,...e});return this.matchs=i,i}getInLibDeps(){const{option:e,matchs:t}=this,{inlibdepReg:i}=e,n=function(e={}){const t={data:[""],localDepReg:[/^\./,/@src/],...e},{localDepReg:i,data:n}=t;let s;return s=n.filter((e=>i.some((t=>t.test(e))))),s}(s({data:t,localDepReg:i}));return this.inLibDeps=n,n}getOutlibDes(){const{option:e,matchs:t}=this,{inlibdepReg:i,nodedeps:n}=e,o=function(e={}){const t={localDep:[""],builintDep:[""],disableLocalDepReg:!1,...e},{data:i,localDep:n,localDepReg:s,builintDep:o}=t;let r;return r=[...i],t.disableLocalDepReg||(r=r.filter((e=>!s.some((t=>t.test(e)))))),n&&(r=a(r,n)),o&&(r=a(r,o)),r;function a(e,t){return function(e,t){return e.filter((e=>!t.some((t=>e===t))))}(e,t.filter((e=>"string"==typeof e)))}}(s({data:t,localDepReg:i,builintDep:n}));return this.outlibDeps=o,this}resolveInLibDeps(e){let t=this.inLibDeps;t=function(e={}){const t={data:[""],skipResolveReg:[/^@private-pkgs/,/^@/],...e},{skipResolveReg:i,fileloc:s}=t;let o=[...t.data];return o=o.map((e=>{if(i.some((t=>t.test(e))))return e;let t=n(function(e,t="/"){const i=e.split(/\/?\\|\//);return i.slice(0,i.length-1).join(t)}(s),e);return t=t.replace(/\\/gi,"/"),t})),o}({data:t,fileloc:e}),this.inLibDeps=t}async parse(e){const{option:t}=this,{parsetasks:i}=t;await this.read(e),this.delComment(),this.getMatchs(),i.includes("in")&&(this.getInLibDeps(),this.resolveInLibDeps(e)),i.includes("out")&&this.getOutlibDes();const{inLibDeps:n,outlibDeps:s}=this;return this.alldeps=[...n,...s],this.alldeps}}}));
