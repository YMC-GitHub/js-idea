/**
  * depTree v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */
"use strict";var t=require("node:fs");
/**
  * streamIo v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */
/**
  * textStreamIo v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */
class e{constructor(t="CHANGELO.md"){this.init(t)}async read(e=""){const{file:i}=this;let s,n;try{s=t.createReadStream(i.name),n=await(r=s,new Promise(((t,e)=>{let i="";r.on("data",(t=>{i+=t.toString()})).on("end",(()=>{t(i)})).on("error",e)})))}catch(t){n=e}var r;return i.data=n,n}async write(e){const{file:i,option:s}=this;let n,r,a;switch(n=t.createWriteStream(i.name),r=i.data,s.writemode){case"override":default:a=`${e}`;break;case"append":a=`${r}\n${e}`;break;case"head":a=`${e}\n${r}`}i.data=a,await function({stream:t,data:e}){return new Promise(((i,s)=>{t.write(e,"utf-8"),t.end(),t.on("finish",(()=>{i(e)})).on("error",s)}))}({stream:n,data:a})}init(t="CHANGELO.md",e=""){return this.file={name:t,data:e},this.option={},this}new(...t){return new e(...t)}}const i=new e;
/**
  * depParse v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */function s(...t){return[...t].map((t=>t.split(/\/?\\|\//))).flat(1/0).filter((t=>t)).join(s.sep?s.sep:"/")}function n(t={}){let e={};return Object.keys(t).forEach((i=>{void 0!==t[i]&&(e[i]=t[i])})),e}class r{constructor(){this.init()}init(){this.option={},this.filetext="",this.matchs=[],this.inLibDeps=[],this.outlibDeps=[],this.alldeps=[],this.deptree={},this.option.inlibdepReg=[/^\./,/@src/],this.option.parsetasks=["in","out"],this.option.nodedeps=["fs","path","os"]}async read(t){return i.init(t),this.filetext=await i.read(),this}delComment(){let{option:t,filetext:e}=this;const{commentReg:i,ignoreComment:s}=t;return e=function(t={}){const e={text:"",ignoreComment:!0,commentReg:[/\/\/.*/gi,/(\/)([*])+(.|\n)+?(\2\1)/gi],...t};let{text:i,commentReg:s}=e;return e.ignoreComment&&s.forEach((t=>{i=i.replace(t,"")})),i}(n({text:e,commentReg:i,ignoreComment:s})),this.filetext=e,this}getMatchs(){const{option:t,filetext:e}=this,i=function(t={}){const e={text:"",requireReg:[/require\(.*\)/gi,/from +("|').*("|')/gi,/import +("|').*("|')/gi],...t},{requireReg:i,text:s}=e;let n;return n=i.map((t=>{let e;return e=s.match(t),e})),n=n.filter((t=>t)),n=n.flat(1),n=[...new Set(n)],n=n.map((t=>{const e="";let s=t;return s.match(i[0])?s=s.replace(/require\(/,e).replace(/\)/,e):s.match(i[1])?s=s.replace(/from +/,e):s.match(i[2])&&(s=s.replace(/import +/,e)),s=s.replace(/^("|')/,e).replace(/("|')$/,e),s})),n=n.map((t=>{let e=1,i=t;return i.match(/^@/)&&(e+=1),i.match(/^.\//)||(i=i.split(/\//).slice(0,e).join("/")),i})),n}({text:e,...t});return this.matchs=i,i}getInLibDeps(){const{option:t,matchs:e}=this,{inlibdepReg:i}=t,s=function(t={}){const e={data:[""],localDepReg:[/^\./,/@src/],...t},{localDepReg:i,data:s}=e;let n;return n=s.filter((t=>i.some((e=>e.test(t))))),n}(n({data:e,localDepReg:i}));return this.inLibDeps=s,s}getOutlibDes(){const{option:t,matchs:e}=this,{inlibdepReg:i,nodedeps:s}=t,r=function(t={}){const e={localDep:[""],builintDep:[""],disableLocalDepReg:!1,...t},{data:i,localDep:s,localDepReg:n,builintDep:r}=e;let a;return a=[...i],e.disableLocalDepReg||(a=a.filter((t=>!n.some((e=>e.test(t)))))),s&&(a=o(a,s)),r&&(a=o(a,r)),a;function o(t,e){return function(t,e){return t.filter((t=>!e.some((e=>t===e))))}(t,e.filter((t=>"string"==typeof t)))}}(n({data:e,localDepReg:i,builintDep:s}));return this.outlibDeps=r,this}resolveInLibDeps(t){let e=this.inLibDeps;e=function(t={}){const e={data:[""],skipResolveReg:[/^@private-pkgs/,/^@/],...t},{skipResolveReg:i,fileloc:n}=e;let r=[...e.data];return r=r.map((t=>{if(i.some((e=>e.test(t))))return t;let e=s(function(t,e="/"){const i=t.split(/\/?\\|\//);return i.slice(0,i.length-1).join(e)}(n),t);return e=e.replace(/\\/gi,"/"),e})),r}({data:e,fileloc:t}),this.inLibDeps=e}async parse(t){const{option:e}=this,{parsetasks:i}=e;await this.read(t),this.delComment(),this.getMatchs(),i.includes("in")&&(this.getInLibDeps(),this.resolveInLibDeps(t)),i.includes("out")&&this.getOutlibDes();const{inLibDeps:s,outlibDeps:n}=this;return this.alldeps=[...s,...n],this.alldeps}}module.exports=class extends r{async getTree(e){const i=new r,s=await i.parse(e),n=s.filter((e=>!/^@/.test(e)&&t.existsSync(e))),a={};a[e]=s;const o=n.map((async t=>{if(!a[t]){const e=await i.parse(t);a[t]=e}}));await Promise.all(o),this.deptree=a}circular(){const{deptree:t}=this,e=[];return Object.keys(t).forEach((i=>{t[i].some((t=>t===i))&&e.push(i)})),e}leaves(){const{deptree:t}=this,e=[],i=Object.keys(t);let s=i.map((e=>t[e]));return s.push(i),s=s.flat(1),s.forEach((i=>{const s=t[i];s&&0!==s.length||e.push(i)})),e}orphans(){const{deptree:t}=this,e=[],i=Object.keys(t);let s=i.map((e=>t[e]));return s.push(i),s=s.flat(1),s.forEach((i=>{const s=t[i];s&&0!==s.length&&(s.some((t=>t===i))||e.push(i))})),e}};
