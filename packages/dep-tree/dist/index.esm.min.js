/**
  * depTree v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */
import{existsSync as e}from"node:fs";import t from"@ymc/dep-parse";class s extends t{async getTree(s){const r=new t,a=await r.parse(s),o=a.filter((t=>!/^@/.test(t)&&e(t))),c={};c[s]=a;const p=o.map((async e=>{if(!c[e]){const t=await r.parse(e);c[e]=t}}));await Promise.all(p),this.deptree=c}circular(){const{deptree:e}=this,t=[];return Object.keys(e).forEach((s=>{e[s].some((e=>e===s))&&t.push(s)})),t}leaves(){const{deptree:e}=this,t=[],s=Object.keys(e);let r=s.map((t=>e[t]));return r.push(s),r=r.flat(1),r.forEach((s=>{const r=e[s];r&&0!==r.length||t.push(s)})),t}orphans(){const{deptree:e}=this,t=[],s=Object.keys(e);let r=s.map((t=>e[t]));return r.push(s),r=r.flat(1),r.forEach((s=>{const r=e[s];r&&0!==r.length&&(r.some((e=>e===s))||t.push(s))})),t}}export{s as default};
