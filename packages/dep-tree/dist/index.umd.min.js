/**
  * depTree v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t(require("node:fs")):"function"==typeof define&&define.amd?define(["node:fs"],t):(e="undefined"!=typeof globalThis?globalThis:e||self)["dep-tree"]=t(e.node_fs)}(this,(function(e){"use strict";
/**
    * streamIo v1.0.0
    * (c) 2018-2022 ymc
    * @license MIT
    */
/**
    * textStreamIo v1.0.0
    * (c) 2018-2022 ymc
    * @license MIT
    */
class t{constructor(e="CHANGELO.md"){this.init(e)}async read(t=""){const{file:i}=this;let s,n;try{s=e.createReadStream(i.name),n=await(r=s,new Promise(((e,t)=>{let i="";r.on("data",(e=>{i+=e.toString()})).on("end",(()=>{e(i)})).on("error",t)})))}catch(e){n=t}var r;return i.data=n,n}async write(t){const{file:i,option:s}=this;let n,r,o;switch(n=e.createWriteStream(i.name),r=i.data,s.writemode){case"override":default:o=`${t}`;break;case"append":o=`${r}\n${t}`;break;case"head":o=`${t}\n${r}`}i.data=o,await function({stream:e,data:t}){return new Promise(((i,s)=>{e.write(t,"utf-8"),e.end(),e.on("finish",(()=>{i(t)})).on("error",s)}))}({stream:n,data:o})}init(e="CHANGELO.md",t=""){return this.file={name:e,data:t},this.option={},this}new(...e){return new t(...e)}}const i=new t;
/**
    * depParse v1.0.0
    * (c) 2018-2022 ymc
    * @license MIT
    */function s(...e){return[...e].map((e=>e.split(/\/?\\|\//))).flat(1/0).filter((e=>e)).join(s.sep?s.sep:"/")}function n(e={}){let t={};return Object.keys(e).forEach((i=>{void 0!==e[i]&&(t[i]=e[i])})),t}class r{constructor(){this.init()}init(){this.option={},this.filetext="",this.matchs=[],this.inLibDeps=[],this.outlibDeps=[],this.alldeps=[],this.deptree={},this.option.inlibdepReg=[/^\./,/@src/],this.option.parsetasks=["in","out"],this.option.nodedeps=["fs","path","os"]}async read(e){return i.init(e),this.filetext=await i.read(),this}delComment(){let{option:e,filetext:t}=this;const{commentReg:i,ignoreComment:s}=e;return t=function(e={}){const t={text:"",ignoreComment:!0,commentReg:[/\/\/.*/gi,/(\/)([*])+(.|\n)+?(\2\1)/gi],...e};let{text:i,commentReg:s}=t;return t.ignoreComment&&s.forEach((e=>{i=i.replace(e,"")})),i}(n({text:t,commentReg:i,ignoreComment:s})),this.filetext=t,this}getMatchs(){const{option:e,filetext:t}=this,i=function(e={}){const t={text:"",requireReg:[/require\(.*\)/gi,/from +("|').*("|')/gi,/import +("|').*("|')/gi],...e},{requireReg:i,text:s}=t;let n;return n=i.map((e=>{let t;return t=s.match(e),t})),n=n.filter((e=>e)),n=n.flat(1),n=[...new Set(n)],n=n.map((e=>{const t="";let s=e;return s.match(i[0])?s=s.replace(/require\(/,t).replace(/\)/,t):s.match(i[1])?s=s.replace(/from +/,t):s.match(i[2])&&(s=s.replace(/import +/,t)),s=s.replace(/^("|')/,t).replace(/("|')$/,t),s})),n=n.map((e=>{let t=1,i=e;return i.match(/^@/)&&(t+=1),i.match(/^.\//)||(i=i.split(/\//).slice(0,t).join("/")),i})),n}({text:t,...e});return this.matchs=i,i}getInLibDeps(){const{option:e,matchs:t}=this,{inlibdepReg:i}=e,s=function(e={}){const t={data:[""],localDepReg:[/^\./,/@src/],...e},{localDepReg:i,data:s}=t;let n;return n=s.filter((e=>i.some((t=>t.test(e))))),n}(n({data:t,localDepReg:i}));return this.inLibDeps=s,s}getOutlibDes(){const{option:e,matchs:t}=this,{inlibdepReg:i,nodedeps:s}=e,r=function(e={}){const t={localDep:[""],builintDep:[""],disableLocalDepReg:!1,...e},{data:i,localDep:s,localDepReg:n,builintDep:r}=t;let o;return o=[...i],t.disableLocalDepReg||(o=o.filter((e=>!n.some((t=>t.test(e)))))),s&&(o=a(o,s)),r&&(o=a(o,r)),o;function a(e,t){return function(e,t){return e.filter((e=>!t.some((t=>e===t))))}(e,t.filter((e=>"string"==typeof e)))}}(n({data:t,localDepReg:i,builintDep:s}));return this.outlibDeps=r,this}resolveInLibDeps(e){let t=this.inLibDeps;t=function(e={}){const t={data:[""],skipResolveReg:[/^@private-pkgs/,/^@/],...e},{skipResolveReg:i,fileloc:n}=t;let r=[...t.data];return r=r.map((e=>{if(i.some((t=>t.test(e))))return e;let t=s(function(e,t="/"){const i=e.split(/\/?\\|\//);return i.slice(0,i.length-1).join(t)}(n),e);return t=t.replace(/\\/gi,"/"),t})),r}({data:t,fileloc:e}),this.inLibDeps=t}async parse(e){const{option:t}=this,{parsetasks:i}=t;await this.read(e),this.delComment(),this.getMatchs(),i.includes("in")&&(this.getInLibDeps(),this.resolveInLibDeps(e)),i.includes("out")&&this.getOutlibDes();const{inLibDeps:s,outlibDeps:n}=this;return this.alldeps=[...s,...n],this.alldeps}}return class extends r{async getTree(t){const i=new r,s=await i.parse(t),n=s.filter((t=>!/^@/.test(t)&&e.existsSync(t))),o={};o[t]=s;const a=n.map((async e=>{if(!o[e]){const t=await i.parse(e);o[e]=t}}));await Promise.all(a),this.deptree=o}circular(){const{deptree:e}=this,t=[];return Object.keys(e).forEach((i=>{e[i].some((e=>e===i))&&t.push(i)})),t}leaves(){const{deptree:e}=this,t=[],i=Object.keys(e);let s=i.map((t=>e[t]));return s.push(i),s=s.flat(1),s.forEach((i=>{const s=e[i];s&&0!==s.length||t.push(i)})),t}orphans(){const{deptree:e}=this,t=[],i=Object.keys(e);let s=i.map((t=>e[t]));return s.push(i),s=s.flat(1),s.forEach((i=>{const s=e[i];s&&0!==s.length&&(s.some((e=>e===i))||t.push(i))})),t}}}));
