/**
  * getCmtedPkg v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t(require("node:child_process"),require("node:fs")):"function"==typeof define&&define.amd?define(["node:child_process","node:fs"],t):(e="undefined"!=typeof globalThis?globalThis:e||self)["get-cmted-pkg"]=t(e.node_child_process,e.node_fs)}(this,(function(e,t){"use strict";
/**
    * runBash v0.0.3
    * (c) 2018-2022 ymc
    * @license MIT
    */function n(e){return e.split(/\r?\n/).map((e=>e.trim())).filter((e=>e)).join("\n")}const o=(t,o,i)=>new Promise(((r,s)=>{i||(i=o,o=t,t="");const a=((e,t=" ")=>Array.isArray(e)?e.join(t):e)(o);(i.exec?i.exec:e.exec)(`${t=t?`${t} ${a}`:`${a}`}`,i,((e,t,o)=>{const{fixUnreadbleCode:a}=i;if(a){const{iconvDesEncoding:e,iconvSrcEncoding:n}=i;t&&(t=a(t,e,n)),o&&(o=a(o,e,n))}e&&i.exitWhenErr&&s(e),i.noTrimOut||(t=n(t),o=n(o)),i.rejectStderr&&(o&&s(e),r(t)),r({stdout:t,stderr:o})}))})),i={exec:e.exec};
/**
    * jsonStreamIo v1.0.0
    * (c) 2018-2022 ymc
    * @license MIT
    */
class r{constructor(e,t){this.init(e,t)}async read(e={}){const{file:n}=this;let o,i;try{o=t.createReadStream(n.name),i=await(r=o,new Promise(((e,t)=>{let n="";r.on("data",(e=>{n+=e.toString()})).on("end",(()=>{e(n)})).on("error",t)}))),i=JSON.parse(i)}catch(t){i=e}
/**
    * streamIo v1.0.0
    * (c) 2018-2022 ymc
    * @license MIT
    */
var r;return n.data=i,i}async write(e){const{file:n,option:o}=this;let i,r=e;try{i=t.createWriteStream(n.name),e?n.data=e:r=n.data,await function({stream:e,data:t}){return new Promise(((n,o)=>{e.write(t,"utf-8"),e.end(),e.on("finish",(()=>{n(t)})).on("error",o)}))}({stream:i,data:JSON.stringify(r,null,2)})}catch(e){}}init(e="package.json",t={}){this.file={name:e,data:t},this.option={}}new(...e){return new r(...e)}}const s=new r,{log:a}=console;function c(e){return function(...t){e&&a(...t)}}return async function(e={}){const t={out:"pkgs-cmted.tmp.json",packageslocReg:/^packages\//,logInfo:!1,logTask:!1,...e},{packageslocReg:n}=t,r=c(t.logInfo);let l;c(t.logTask)("[task] read commited pkgs from gitlog"),r("[info] read commited pkgs"),l=await async function(e,t){const{stdout:n,stderr:i}=await o(e,t);return n}("git ls-tree --full-tree --name-only -r HEAD",i),l=l.split(/\r?\n/).filter((e=>e)),l=await async function(e={}){const t={EOFReg:/\r?\n/,pathSplit:"/",packageslocReg:/^packages\//,files:"",for:"pkg-name",...e};let{files:n}=t;if(!n)return[];n=n.filter((e=>t.packageslocReg.test(e)));const o=t.pathSplit;if("pkg-loc"===t.for.toLowerCase())n=n.map((e=>e.split(o).slice(0,2).join(o))).filter((e=>e));else n=n.map((e=>e.split(o)[1])).filter((e=>e));return n=[...new Set(n)],n}({files:l,for:"pkg-loc",packageslocReg:n}),a(l.join("\n")),r("[info] save commited pkgs");let f=t.out;return s.init(f),await s.write(l),r(`[info] out: ${f}`),l}}));
