/**
  * gitCommitLogsInfo v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */
"use strict";var t=require("node:child_process"),e=require("node:fs");function n(t){return t.split(/\r?\n/).map((t=>t.trim())).filter((t=>t)).join("\n")}const i=(e,i,r)=>new Promise(((o,s)=>{r||(r=i,i=e,e="");const a=((t,e=" ")=>Array.isArray(t)?t.join(e):t)(i);(r.exec?r.exec:t.exec)(`${e=e?`${e} ${a}`:`${a}`}`,r,((t,e,i)=>{const{fixUnreadbleCode:a}=r;if(a){const{iconvDesEncoding:t,iconvSrcEncoding:n}=r;e&&(e=a(e,t,n)),i&&(i=a(i,t,n))}t&&r.exitWhenErr&&s(t),r.noTrimOut||(e=n(e),i=n(i)),r.rejectStderr&&(i&&s(t),o(e)),o({stdout:e,stderr:i})}))})),r={exec:t.exec};
/**
  * renderTpl v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */
function o(t,e){let n=t;return Object.keys(e).forEach((t=>{const i=e[t];n=n.replace(new RegExp(`{${t}}`,"ig"),i)})),n}function s(t,e){return e?o(t,e):e=>o(t,e)}
/**
  * gitCommitMsgParse v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */function a(t){return void 0!==t}function c(t,e,n){let i,r,o,s;if(e)[o,s]=[t,e];else{const e=t.trim().split(/\r?\n/).map((t=>t.trim().split("\\n"))).flat(1).map((t=>t.trim()));[o]=e,s=e.slice(1).join("\n"),s||(s=o)}const c=function(t=""){let e;const n={body:t,foot:""};let i,r,o,s;e=t.replace(/\\\\n/gi,"\n"),i=function(t){return t.trim().split(/\r?\n/)}(e);for(let t=0;t<i.length;t+=1){const e=i[t];if(!a(r)&&e.match(/^BREAKING CHANGE/i)&&(r=t),!a(o)&&e.match(/^CLOSING ISSUE/i)&&(o=t),!a(s)&&e.match(/^generated by/i)&&(s=t),a(o)&&a(r)&&a(s))break}let c=-1;return a(o)||(o=-1),a(r)||(r=-1),a(s)||(s=-1),c=Math.max(o,r,s),c>=0&&c<=i.length&&(n.foot=i.slice(c).join("\n").trim(),n.body=c>0?i.slice(0,c).join("\n").trim():""),n}(s);return i=function(t,e){const n=/\(.*\):?/gi;if(t.match(n))return t.split(":")[0].replace(n,"");let i=t.split(" ")[0].trim().replace(/\(.*\):?/gi,"").trim();return function(t,e="feat|fix|docs|style|refactor|preform|test|tool|chore|revert"){return n=t,e.split("|").some((t=>t===n));var n}(i,e)||(i=""),i}(o,n),r=function(t=""){const e=t.match(/\(.*\)/gi);let n="";return e&&([n]=e),n=n.replace(/(^\(|\)$)/gi,""),n}(o),o=o.replace(i,"").replace(/\(.*\):?/i,"").trim(),{type:i,scope:r,subject:o,...c}}
/**
  * gitCommitMsgRead v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */function l(t){return t.trim().split(/\r?\n/)}async function u(t,e){const{stdout:n,stderr:r}=await i(t,e);return n}const f=new class{constructor(){this.infojson=[],this.options={},this.status={}}set(t,e){const{infojson:n,status:i}=this;var r,o,s;return i.initeddata||(s={},(r=n)[o=t]||(r[o]=s),i.initeddata=!0),function(t=[],e="subject",n=[]){if(n.length!==t.length)return;const i=t.length;for(let r=0;r<i;r+=1)t[r][`${e}`]=n[r]}(n,t,e),this}getTpl(t,e={}){let n=t,i={...e,...this.options};return i.n&&(n=`${t} -n ${i.n}`),n}async getHash(){let t,e,n;return t='git log --pretty=format:"%H" --abbrev-commit',t=this.getTpl(t),e=s(t,{}),n=await u(e,r),n}async getSubject(){let t,e,n;return t='git log --pretty=format:"%s" --abbrev-commit',t=this.getTpl(t),e=s(t,{}),n=await u(e,r),n}async getBody(){let t,e,n;return t='git log --pretty=format:"%b"',t=this.getTpl(t),e=s(t,{}),n=await u(e,r),n}async getDate(){let t,e,n;return t='git log --pretty=format:"%as"',t=this.getTpl(t),e=s(t,{}),n=await u(e,r),n}async getFile(t,e){const n=[];for(let e=0;e<t.length;e+=1){const r=t[e],o=await i(r);o&&n.push(l(o))}return n;async function i(t){return u(s(e||'git show --pretty="" --name-only {commit}',{commit:t}),r)}}async getinfo(){let t,e,n,i,r,o,s;return t=await this.getHash(),t=l(t),e=await this.getSubject(),e=l(e),o='git log -n 1 --pretty=format:"%b" {commit}',n=await this.getFile(t,'git log -n 1 --pretty=format:"%b" {commit}'),n=n.map((t=>t.join("\n"))),r=await this.getDate(),r=l(r),i=await this.getFile(t),s=t.map(((t,o)=>({commit:t.slice(1,10),subject:e,body:n,issue:[""],hash:t,file:i[o],date:r[o]}))),this.infojson=s,s}async parse(){let t=await this.getinfo();return t=t.map(((t,e)=>{let{subject:n,body:i}=t;const r=c(n[e],i[e]);let o=function(t,e=/#\d+/gi){const n=t.match(e);let i=[];return n&&(i=n),i}(r.foot);return{...t,...r,issue:o}})),this.infojson=t,t}filterInfoByFile(t=/.*/i){const{infojson:e}=this;return e.filter((e=>!(!e||!e.file)&&e.file.some((e=>t.test(e)))))}filterSinceLastChanglog(t,e){const n=[];for(let i=0;i<t.length;i+=1){const r=t[i];if(r.commit===e)break;n.push(r)}return n}};
/**
  * streamIo v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */
/**
  * jsonStreamIo v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */
class m{constructor(t,e){this.init(t,e)}async read(t={}){const{file:n}=this;let i,r;try{i=e.createReadStream(n.name),r=await(o=i,new Promise(((t,e)=>{let n="";o.on("data",(t=>{n+=t.toString()})).on("end",(()=>{t(n)})).on("error",e)}))),r=JSON.parse(r)}catch(e){r=t}var o;return n.data=r,r}async write(t){const{file:n,option:i}=this;let r,o=t;try{r=e.createWriteStream(n.name),t?n.data=t:o=n.data,await function({stream:t,data:e}){return new Promise(((n,i)=>{t.write(e,"utf-8"),t.end(),t.on("finish",(()=>{n(e)})).on("error",i)}))}({stream:r,data:JSON.stringify(o,null,2)})}catch(t){}}init(t="package.json",e={}){this.file={name:t,data:e},this.option={}}new(...t){return new m(...t)}}const g=new m,{log:h}=console;function p(t){return function(...e){t&&h(...e)}}module.exports=async function(t={}){const e={out:"gitlog-info.shim.tmp.json",n:10,logInfo:!1,logTask:!1,...t},n=p(e.logInfo),i=p(e.logTask),r=e.out;let o;i(`[task] update git commited logs to ${r}`),e.n&&(n("[info] read the last gitlog"),f.options.n=e.n);const s=await f.parse();n("[info] store gitlog"),g.init(r),o=await g.read([]);let a=0;s.forEach((t=>{o.some((e=>e.hash===t.hash))||(o.unshift(t),a+=1)})),await g.write(o),n(`[info] out: ${r}`),h(`[info] update count: ${a}`)};
