/**
  * gitCommitLogsInfo v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */
"use strict";var t=require("node:child_process"),e=require("node:fs");function n(t){return t.split(/\r?\n/).map((t=>t.trim())).filter((t=>t)).join("\n")}const i=(e,i,r)=>new Promise(((o,s)=>{r||(r=i,i=e,e="");const a=((t,e=" ")=>Array.isArray(t)?t.join(e):t)(i);(r.exec?r.exec:t.exec)(`${e=e?`${e} ${a}`:`${a}`}`,r,((t,e,i)=>{const{fixUnreadbleCode:a}=r;if(a){const{iconvDesEncoding:t,iconvSrcEncoding:n}=r;e&&(e=a(e,t,n)),i&&(i=a(i,t,n))}t&&r.exitWhenErr&&s(t),r.noTrimOut||(e=n(e),i=n(i)),r.rejectStderr&&(i&&s(t),o(e)),o({stdout:e,stderr:i})}))})),r={exec:t.exec};
/**
  * jsonStreamIo v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */
class o{constructor(t,e){this.init(t,e)}async read(t={}){const{file:n}=this;let i,r;try{i=e.createReadStream(n.name),r=await(o=i,new Promise(((t,e)=>{let n="";o.on("data",(t=>{n+=t.toString()})).on("end",(()=>{t(n)})).on("error",e)}))),r=JSON.parse(r)}catch(e){r=t}
/**
  * streamIo v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */
var o;return n.data=r,r}async write(t){const{file:n,option:i}=this;let r,o=t;try{r=e.createWriteStream(n.name),t?n.data=t:o=n.data,await function({stream:t,data:e}){return new Promise(((n,i)=>{t.write(e,"utf-8"),t.end(),t.on("finish",(()=>{n(e)})).on("error",i)}))}({stream:r,data:JSON.stringify(o,null,2)})}catch(t){}}init(t="package.json",e={}){this.file={name:t,data:e},this.option={}}new(...t){return new o(...t)}}const s=new o;
/**
  * renderTpl v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */function a(t,e){let n=t;return Object.keys(e).forEach((t=>{const i=e[t];n=n.replace(new RegExp(`{${t}}`,"ig"),i)})),n}function c(t,e){return e?a(t,e):e=>a(t,e)}
/**
  * gitCommitMsgParse v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */function l(t){return void 0!==t}function u(t,e,n){let i,r,o,s;if(e)[o,s]=[t,e];else{const e=t.trim().split(/\r?\n/).map((t=>t.trim().split("\\n"))).flat(1).map((t=>t.trim()));[o]=e,s=e.slice(1).join("\n"),s||(s=o)}const a=function(t=""){let e;const n={body:t,foot:""};let i,r,o,s;e=t.replace(/\\\\n/gi,"\n"),i=function(t){return t.trim().split(/\r?\n/)}(e);for(let t=0;t<i.length;t+=1){const e=i[t];if(!l(r)&&e.match(/^BREAKING CHANGE/i)&&(r=t),!l(o)&&e.match(/^CLOSING ISSUE/i)&&(o=t),!l(s)&&e.match(/^generated by/i)&&(s=t),l(o)&&l(r)&&l(s))break}let a=-1;return l(o)||(o=-1),l(r)||(r=-1),l(s)||(s=-1),a=Math.max(o,r,s),a>=0&&a<=i.length&&(n.foot=i.slice(a).join("\n").trim(),n.body=a>0?i.slice(0,a).join("\n").trim():""),n}(s);return i=function(t,e){const n=/\(.*\):?/gi;if(t.match(n))return t.split(":")[0].replace(n,"");let i=t.split(" ")[0].trim().replace(/\(.*\):?/gi,"").trim();return function(t,e="feat|fix|docs|style|refactor|preform|test|tool|chore|revert"){return n=t,e.split("|").some((t=>t===n));var n}(i,e)||(i=""),i}(o,n),r=function(t=""){const e=t.match(/\(.*\)/gi);let n="";return e&&([n]=e),n=n.replace(/(^\(|\)$)/gi,""),n}(o),o=o.replace(i,"").replace(/\(.*\):?/i,"").trim(),{type:i,scope:r,subject:o,...a}}
/**
  * gitCommitMsgRead v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */function f(t){return t.trim().split(/\r?\n/)}async function g(t,e){const{stdout:n,stderr:r}=await i(t,e);return n}const m=new class{constructor(){this.infojson=[],this.options={},this.status={}}set(t,e){const{infojson:n,status:i}=this;var r,o,s;return i.initeddata||(s={},(r=n)[o=t]||(r[o]=s),i.initeddata=!0),function(t=[],e="subject",n=[]){if(n.length!==t.length)return;const i=t.length;for(let r=0;r<i;r+=1)t[r][`${e}`]=n[r]}(n,t,e),this}getTpl(t,e={}){let n={...e,...this.options};return n.n&&(t=`${t} -n ${n.n}`),t}async getHash(){let t,e,n;return t='git log --pretty=format:"%H" --abbrev-commit',t=this.getTpl(t),e=c(t,{}),n=await g(e,r),n}async getSubject(){let t,e,n;return t='git log --pretty=format:"%s" --abbrev-commit',t=this.getTpl(t),e=c(t,{}),n=await g(e,r),n}async getBody(){let t,e,n;return t='git log --pretty=format:"%b"',t=this.getTpl(t),e=c(t,{}),n=await g(e,r),n}async getDate(){let t,e,n;return t='git log --pretty=format:"%as"',t=this.getTpl(t),e=c(t,{}),n=await g(e,r),n}async getFile(t,e){let n='git show --pretty="" --name-only {commit}';n=this.getTpl(n);const i=[];for(let e=0;e<t.length;e+=1){const n=t[e],r=await o(n);r&&i.push(f(r))}return i;async function o(t){return g(c(e||n,{commit:t}),r)}}async getinfo(){let t,e,n,i,r,o,s;return t=await this.getHash(),t=f(t),e=await this.getSubject(),e=f(e),o='git log -n 1 --pretty=format:"%b" {commit}',n=await this.getFile(t,'git log -n 1 --pretty=format:"%b" {commit}'),n=n.map((t=>t.join("\n"))),r=await this.getDate(),r=f(r),i=await this.getFile(t),s=t.map(((t,o)=>({commit:t.slice(1,10),subject:e,body:n,issue:[""],hash:t,file:i[o],date:r[o]}))),this.infojson=s,s}async parse(){let t=await this.getinfo();return t=t.map(((t,e)=>{let{subject:n,body:i}=t;const r=u(n[e],i[e]);let o=function(t,e=/#\d+/gi){const n=t.match(e);let i=[];return n&&(i=n),i}(r.foot);return{...t,...r,issue:o}})),this.infojson=t,t}filterInfoByFile(t=/.*/i){const{infojson:e}=this;return e.filter((e=>!(!e||!e.file)&&e.file.some((e=>t.test(e)))))}filterSinceLastChanglog(t,e){const n=[];for(let i=0;i<t.length;i+=1){const r=t[i];if(r.commit===e)break;n.push(r)}return n}},{log:h}=console;function p(t){return function(...e){t&&h(...e)}}module.exports=async function(t={}){const e={out:"gitlog-info.shim.tmp.json",n:10,logInfo:!1,logTask:!1,...t},n=p(e.logInfo),i=p(e.logTask);let r,o=e.out;i(`[task] update git commited logs to ${o}`),e.n&&(n("[info] read the last gitlog"),m.options.n=e.n);const a=await m.parse();n("[info] store gitlog"),s.init(o),r=await s.read([]);let c=0;a.forEach((t=>{r.some((e=>e.hash===t.hash))||(r.unshift(t),c+=1)})),await s.write(r),n(`[info] out: ${o}`),h(`[info] update count: ${c}`)};
