/**
  * gitCommitLogsInfo v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e(require("node:child_process"),require("node:fs")):"function"==typeof define&&define.amd?define(["node:child_process","node:fs"],e):(t="undefined"!=typeof globalThis?globalThis:t||self)["git-commit-logs-info"]=e(t.node_child_process,t.node_fs)}(this,(function(t,e){"use strict";
/**
    * runBash v0.0.3
    * (c) 2018-2022 ymc
    * @license MIT
    */function n(t){return t.split(/\r?\n/).map((t=>t.trim())).filter((t=>t)).join("\n")}const i=(e,i,o)=>new Promise(((r,s)=>{o||(o=i,i=e,e="");const a=((t,e=" ")=>Array.isArray(t)?t.join(e):t)(i);(o.exec?o.exec:t.exec)(`${e=e?`${e} ${a}`:`${a}`}`,o,((t,e,i)=>{const{fixUnreadbleCode:a}=o;if(a){const{iconvDesEncoding:t,iconvSrcEncoding:n}=o;e&&(e=a(e,t,n)),i&&(i=a(i,t,n))}t&&o.exitWhenErr&&s(t),o.noTrimOut||(e=n(e),i=n(i)),o.rejectStderr&&(i&&s(t),r(e)),r({stdout:e,stderr:i})}))})),o={exec:t.exec};
/**
    * renderTpl v1.0.0
    * (c) 2018-2022 ymc
    * @license MIT
    */
function r(t,e){let n=t;return Object.keys(e).forEach((t=>{const i=e[t];n=n.replace(new RegExp(`{${t}}`,"ig"),i)})),n}function s(t,e){return e?r(t,e):e=>r(t,e)}
/**
    * gitCommitMsgParse v1.0.0
    * (c) 2018-2022 ymc
    * @license MIT
    */function a(t){return void 0!==t}function c(t,e,n){let i,o,r,s;if(e)[r,s]=[t,e];else{const e=t.trim().split(/\r?\n/).map((t=>t.trim().split("\\n"))).flat(1).map((t=>t.trim()));[r]=e,s=e.slice(1).join("\n"),s||(s=r)}const c=function(t=""){let e;const n={body:t,foot:""};let i,o,r,s;e=t.replace(/\\\\n/gi,"\n"),i=function(t){return t.trim().split(/\r?\n/)}(e);for(let t=0;t<i.length;t+=1){const e=i[t];if(!a(o)&&e.match(/^BREAKING CHANGE/i)&&(o=t),!a(r)&&e.match(/^CLOSING ISSUE/i)&&(r=t),!a(s)&&e.match(/^generated by/i)&&(s=t),a(r)&&a(o)&&a(s))break}let c=-1;return a(r)||(r=-1),a(o)||(o=-1),a(s)||(s=-1),c=Math.max(r,o,s),c>=0&&c<=i.length&&(n.foot=i.slice(c).join("\n").trim(),n.body=c>0?i.slice(0,c).join("\n").trim():""),n}(s);return i=function(t,e){const n=/\(.*\):?/gi;if(t.match(n))return t.split(":")[0].replace(n,"");let i=t.split(" ")[0].trim().replace(/\(.*\):?/gi,"").trim();return function(t,e="feat|fix|docs|style|refactor|preform|test|tool|chore|revert"){return n=t,e.split("|").some((t=>t===n));var n}(i,e)||(i=""),i}(r,n),o=function(t=""){const e=t.match(/\(.*\)/gi);let n="";return e&&([n]=e),n=n.replace(/(^\(|\)$)/gi,""),n}(r),r=r.replace(i,"").replace(/\(.*\):?/i,"").trim(),{type:i,scope:o,subject:r,...c}}
/**
    * gitCommitMsgRead v1.0.0
    * (c) 2018-2022 ymc
    * @license MIT
    */function l(t){return t.trim().split(/\r?\n/)}async function f(t,e){const{stdout:n,stderr:o}=await i(t,e);return n}const u=new class{constructor(){this.infojson=[],this.options={},this.status={}}set(t,e){const{infojson:n,status:i}=this;var o,r,s;return i.initeddata||(s={},(o=n)[r=t]||(o[r]=s),i.initeddata=!0),function(t=[],e="subject",n=[]){if(n.length!==t.length)return;const i=t.length;for(let o=0;o<i;o+=1)t[o][`${e}`]=n[o]}(n,t,e),this}getTpl(t,e={}){let n=t,i={...e,...this.options};return i.n&&(n=`${t} -n ${i.n}`),n}async getHash(){let t,e,n;return t='git log --pretty=format:"%H" --abbrev-commit',t=this.getTpl(t),e=s(t,{}),n=await f(e,o),n}async getSubject(){let t,e,n;return t='git log --pretty=format:"%s" --abbrev-commit',t=this.getTpl(t),e=s(t,{}),n=await f(e,o),n}async getBody(){let t,e,n;return t='git log --pretty=format:"%b"',t=this.getTpl(t),e=s(t,{}),n=await f(e,o),n}async getDate(){let t,e,n;return t='git log --pretty=format:"%as"',t=this.getTpl(t),e=s(t,{}),n=await f(e,o),n}async getFile(t,e){const n=[];for(let e=0;e<t.length;e+=1){const o=t[e],r=await i(o);r&&n.push(l(r))}return n;async function i(t){return f(s(e||'git show --pretty="" --name-only {commit}',{commit:t}),o)}}async getinfo(){let t,e,n,i,o,r,s;return t=await this.getHash(),t=l(t),e=await this.getSubject(),e=l(e),r='git log -n 1 --pretty=format:"%b" {commit}',n=await this.getFile(t,'git log -n 1 --pretty=format:"%b" {commit}'),n=n.map((t=>t.join("\n"))),o=await this.getDate(),o=l(o),i=await this.getFile(t),s=t.map(((t,r)=>({commit:t.slice(1,10),subject:e,body:n,issue:[""],hash:t,file:i[r],date:o[r]}))),this.infojson=s,s}async parse(){let t=await this.getinfo();return t=t.map(((t,e)=>{let{subject:n,body:i}=t;const o=c(n[e],i[e]);let r=function(t,e=/#\d+/gi){const n=t.match(e);let i=[];return n&&(i=n),i}(o.foot);return{...t,...o,issue:r}})),this.infojson=t,t}filterInfoByFile(t=/.*/i){const{infojson:e}=this;return e.filter((e=>!(!e||!e.file)&&e.file.some((e=>t.test(e)))))}filterSinceLastChanglog(t,e){const n=[];for(let i=0;i<t.length;i+=1){const o=t[i];if(o.commit===e)break;n.push(o)}return n}};
/**
    * streamIo v1.0.0
    * (c) 2018-2022 ymc
    * @license MIT
    */
/**
    * jsonStreamIo v1.0.0
    * (c) 2018-2022 ymc
    * @license MIT
    */
class m{constructor(t,e){this.init(t,e)}async read(t={}){const{file:n}=this;let i,o;try{i=e.createReadStream(n.name),o=await(r=i,new Promise(((t,e)=>{let n="";r.on("data",(t=>{n+=t.toString()})).on("end",(()=>{t(n)})).on("error",e)}))),o=JSON.parse(o)}catch(e){o=t}var r;return n.data=o,o}async write(t){const{file:n,option:i}=this;let o,r=t;try{o=e.createWriteStream(n.name),t?n.data=t:r=n.data,await function({stream:t,data:e}){return new Promise(((n,i)=>{t.write(e,"utf-8"),t.end(),t.on("finish",(()=>{n(e)})).on("error",i)}))}({stream:o,data:JSON.stringify(r,null,2)})}catch(t){}}init(t="package.json",e={}){this.file={name:t,data:e},this.option={}}new(...t){return new m(...t)}}const g=new m,{log:h}=console;function p(t){return function(...e){t&&h(...e)}}return async function(t={}){const e={out:"gitlog-info.shim.tmp.json",n:10,logInfo:!1,logTask:!1,...t},n=p(e.logInfo),i=p(e.logTask),o=e.out;let r;i(`[task] update git commited logs to ${o}`),e.n&&(n("[info] read the last gitlog"),u.options.n=e.n);const s=await u.parse();n("[info] store gitlog"),g.init(o),r=await g.read([]);let a=0;s.forEach((t=>{r.some((e=>e.hash===t.hash))||(r.unshift(t),a+=1)})),await g.write(r),n(`[info] out: ${o}`),h(`[info] update count: ${a}`)}}));
