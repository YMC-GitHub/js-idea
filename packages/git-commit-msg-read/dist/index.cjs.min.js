/**
  * gitCommitMsgRead v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t=require("node:child_process");
/**
  * runBash v0.0.3
  * (c) 2018-2022 ymc
  * @license MIT
  */function e(t){return t.split(/\r?\n/).map((t=>t.trim())).filter((t=>t)).join("\n")}const n=(n,i,r)=>new Promise(((o,s)=>{r||(r=i,i=n,n="");const c=((t,e=" ")=>Array.isArray(t)?t.join(e):t)(i);(r.exec?r.exec:t.exec)(`${n=n?`${n} ${c}`:`${c}`}`,r,((t,n,i)=>{const{fixUnreadbleCode:c}=r;if(c){const{iconvDesEncoding:t,iconvSrcEncoding:e}=r;n&&(n=c(n,t,e)),i&&(i=c(i,t,e))}t&&r.exitWhenErr&&s(t),r.noTrimOut||(n=e(n),i=e(i)),r.rejectStderr&&(i&&s(t),o(n)),o({stdout:n,stderr:i})}))})),i={exec:t.exec};
/**
  * renderTpl v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */
function r(t,e){let n=t;return Object.keys(e).forEach((t=>{const i=e[t];n=n.replace(new RegExp(`{${t}}`,"ig"),i)})),n}function o(t,e){return e?r(t,e):e=>r(t,e)}
/**
  * gitCommitMsgParse v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */function s(t){return void 0!==t}function c(t,e,n){let i,r,o,c;if(e)[o,c]=[t,e];else{const e=t.trim().split(/\r?\n/).map((t=>t.trim().split("\\n"))).flat(1).map((t=>t.trim()));[o]=e,c=e.slice(1).join("\n"),c||(c=o)}const a=function(t=""){let e;const n={body:t,foot:""};let i,r,o,c;e=t.replace(/\\\\n/gi,"\n"),i=function(t){return t.trim().split(/\r?\n/)}(e);for(let t=0;t<i.length;t+=1){const e=i[t];if(!s(r)&&e.match(/^BREAKING CHANGE/i)&&(r=t),!s(o)&&e.match(/^CLOSING ISSUE/i)&&(o=t),!s(c)&&e.match(/^generated by/i)&&(c=t),s(o)&&s(r)&&s(c))break}let a=-1;return s(o)||(o=-1),s(r)||(r=-1),s(c)||(c=-1),a=Math.max(o,r,c),a>=0&&a<=i.length&&(n.foot=i.slice(a).join("\n").trim(),n.body=a>0?i.slice(0,a).join("\n").trim():""),n}(c);return i=function(t,e){const n=/\(.*\):?/gi;if(t.match(n))return t.split(":")[0].replace(n,"");let i=t.split(" ")[0].trim().replace(/\(.*\):?/gi,"").trim();return function(t,e="feat|fix|docs|style|refactor|preform|test|tool|chore|revert"){return n=t,e.split("|").some((t=>t===n));var n}(i,e)||(i=""),i}(o,n),r=function(t=""){const e=t.match(/\(.*\)/gi);let n="";return e&&([n]=e),n=n.replace(/(^\(|\)$)/gi,""),n}(o),o=o.replace(i,"").replace(/\(.*\):?/i,"").trim(),{type:i,scope:r,subject:o,...a}}function a(t){return t.trim().split(/\r?\n/)}async function l(t,e){const{stdout:i,stderr:r}=await n(t,e);return i}class u{constructor(){this.infojson=[],this.options={},this.status={}}set(t,e){const{infojson:n,status:i}=this;var r,o,s;return i.initeddata||(s={},(r=n)[o=t]||(r[o]=s),i.initeddata=!0),function(t=[],e="subject",n=[]){if(n.length!==t.length)return;const i=t.length;for(let r=0;r<i;r+=1)t[r][`${e}`]=n[r]}(n,t,e),this}getTpl(t,e={}){let n=t,i={...e,...this.options};return i.n&&(n=`${t} -n ${i.n}`),n}async getHash(){let t,e,n;return t='git log --pretty=format:"%H" --abbrev-commit',t=this.getTpl(t),e=o(t,{}),n=await l(e,i),n}async getSubject(){let t,e,n;return t='git log --pretty=format:"%s" --abbrev-commit',t=this.getTpl(t),e=o(t,{}),n=await l(e,i),n}async getBody(){let t,e,n;return t='git log --pretty=format:"%b"',t=this.getTpl(t),e=o(t,{}),n=await l(e,i),n}async getDate(){let t,e,n;return t='git log --pretty=format:"%as"',t=this.getTpl(t),e=o(t,{}),n=await l(e,i),n}async getFile(t,e){const n=[];for(let e=0;e<t.length;e+=1){const i=t[e],o=await r(i);o&&n.push(a(o))}return n;async function r(t){return l(o(e||'git show --pretty="" --name-only {commit}',{commit:t}),i)}}async getinfo(){let t,e,n,i,r,o,s;return t=await this.getHash(),t=a(t),e=await this.getSubject(),e=a(e),o='git log -n 1 --pretty=format:"%b" {commit}',n=await this.getFile(t,'git log -n 1 --pretty=format:"%b" {commit}'),n=n.map((t=>t.join("\n"))),r=await this.getDate(),r=a(r),i=await this.getFile(t),s=t.map(((t,o)=>({commit:t.slice(1,10),subject:e,body:n,issue:[""],hash:t,file:i[o],date:r[o]}))),this.infojson=s,s}async parse(){let t=await this.getinfo();return t=t.map(((t,e)=>{let{subject:n,body:i}=t;const r=c(n[e],i[e]);let o=function(t,e=/#\d+/gi){const n=t.match(e);let i=[];return n&&(i=n),i}(r.foot);return{...t,...r,issue:o}})),this.infojson=t,t}filterInfoByFile(t=/.*/i){const{infojson:e}=this;return e.filter((e=>!(!e||!e.file)&&e.file.some((e=>t.test(e)))))}filterSinceLastChanglog(t,e){const n=[];for(let i=0;i<t.length;i+=1){const r=t[i];if(r.commit===e)break;n.push(r)}return n}}const f=new u;exports.Store=u,exports.store=f;
