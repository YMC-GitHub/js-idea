/**
  * gitCommitMsgRead v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */
import{exec as t,execOpts as e}from"@ymc/run-bash";import{writeTpl as i}from"@ymc/render-tpl";import{parse as n,getIssueInFoot as s}from"@ymc/git-commit-msg-parse";function o(t){return t.trim().split(/\r?\n/)}async function r(e,i){const{stdout:n,stderr:s}=await t(e,i);return n}class a{constructor(){this.infojson=[],this.options={},this.status={}}set(t,e){const{infojson:i,status:n}=this;var s,o,r;return n.initeddata||(r={},(s=i)[o=t]||(s[o]=r),n.initeddata=!0),function(t=[],e="subject",i=[]){if(i.length!==t.length)return;const n=t.length;for(let s=0;s<n;s+=1)t[s][`${e}`]=i[s]}(i,t,e),this}getTpl(t,e={}){let i=t,n={...e,...this.options};return n.n&&(i=`${t} -n ${n.n}`),i}async getHash(){let t,n,s;return t='git log --pretty=format:"%H" --abbrev-commit',t=this.getTpl(t),n=i(t,{}),s=await r(n,e),s}async getSubject(){let t,n,s;return t='git log --pretty=format:"%s" --abbrev-commit',t=this.getTpl(t),n=i(t,{}),s=await r(n,e),s}async getBody(){let t,n,s;return t='git log --pretty=format:"%b"',t=this.getTpl(t),n=i(t,{}),s=await r(n,e),s}async getDate(){let t,n,s;return t='git log --pretty=format:"%as"',t=this.getTpl(t),n=i(t,{}),s=await r(n,e),s}async getFile(t,n){let s='git show --pretty="" --name-only {commit}';s=this.getTpl(s);const a=[];for(let e=0;e<t.length;e+=1){const i=t[e],n=await l(i);n&&a.push(o(n))}return a;async function l(t){return r(i(n||s,{commit:t}),e)}}async getinfo(){let t,e,i,n,s,r,a;return t=await this.getHash(),t=o(t),e=await this.getSubject(),e=o(e),r='git log -n 1 --pretty=format:"%b" {commit}',i=await this.getFile(t,'git log -n 1 --pretty=format:"%b" {commit}'),i=i.map((t=>t.join("\n"))),s=await this.getDate(),s=o(s),n=await this.getFile(t),a=t.map(((t,o)=>({commit:t.slice(1,10),subject:e,body:i,issue:[""],hash:t,file:n[o],date:s[o]}))),this.infojson=a,a}async parse(){let t=await this.getinfo();return t=t.map(((t,e)=>{let{subject:i,body:o}=t;const r=n(i[e],o[e]);let a=s(r.foot);return{...t,...r,issue:a}})),this.infojson=t,t}filterInfoByFile(t=/.*/i){const{infojson:e}=this;return e.filter((e=>!(!e||!e.file)&&e.file.some((e=>t.test(e)))))}filterSinceLastChanglog(t,e){const i=[];for(let n=0;n<t.length;n+=1){const s=t[n];if(s.commit===e)break;i.push(s)}return i}}const l=new a;export{a as Store,l as store};
