/**
  * jcm v0.0.1
  * (c) 2018-2022 ymc
  * @license MIT
  */
import{rmdirSync as t,existsSync as n,mkdirSync as e,readFileSync as s,writeFileSync as o}from"node:fs";import{dirname as i,parse as r,join as l}from"node:path";const c=(t,n="")=>{const e=new RegExp(` *${t}:.*`,"ig"),s=n.match(e);return s?s[0].replace(new RegExp(` *${t}:`,"i"),""):""},{log:a}=console;class u{constructor(){this.list=[],this.index=-1,this.freeze=!1}use(t={},n){let{list:e,index:s}=this;const o=!n;return o||s==n?s++:s<n&&(s=n),this.index=s,s=o?s:n,t&&(e[s]=t),this}load(){const{list:t}=this;let n={};for(let e=0;e<t.length;e++){const s=t[e];s&&(n={...n,...s})}const{freeze:e}=this;return e?Object.freeze(n):n}}class d{constructor(){this.data={},this.option={splitChar:"."}}bind(t){return t&&(this.data=t),this}split(t="."){return t&&(this.option.splitChar=t),this}conf(t="",n){if(!t)return this;let e,{data:s,option:o}=this;e=(t=t.split(o.splitChar))[t.length-1];const{length:i}=t;for(let n=0;n<i-1;n++){const e=t[n];s[e]||(s[e]={}),s=s[e]}return null==n?s[e]:(s[e]=n,a(`set ${e} ${n}`),this)}}new u,new d;const{log:h}=console;const f=new class{constructor(){this.option={},this.tool={}}getFileLoc(t){const{option:n,tool:e}=this,s=t||n.name,o=n;return o.usd||o.u?e.joinPath(e.getUserHome(),s):o.crd||o.c?s:o.wkd?(h(s,n),e.joinPath(o.wkd,s)):s}getFileLocList(t){let n=[];const{option:e}=this;return n=[["usd","u"],["crd","c"],["wkd"]].map((n=>{let s,o,i;for(let t=0;t<n.length;t++){const r=n[t];if(e[r]){o=e[r],s=r,i=!0;break}}return!!i&&(this.option={[`${s}`]:o,name:e.name},this.getFileLoc(t))})).filter((t=>t)),this.option=e,n}magicReadConfig(t=".ymcrc.json"){const{tool:n}=this;return function(t=[".ymcrc.json"],n){const e=new u;for(let s=0;s<t.length;s++){const o=t[s];e.use(n(o))}return e.load()}(this.getFileLocList(t),n.readJson)}magicDefineConfig(t,n,e){const s=new d;return s.bind(t),s.split("/"),s.conf(n,e),s.data}getJsonVal(t="key",n="val"){const{data:e}=this;let s;if(t)return s=e[n],h(s),s}setJsonVal(t,n,e){const{option:s,tool:o}=this,i=this,{name:r}=s;let l,c;l=i.magicReadConfig(r),t&&e&&(l=i.magicDefineConfig(l,t,n)),c=i.getFileLocList(r),c=c[c.length-1];const a=o.parsePath(c).dir;a&&o.addDirs(a),s.dryrun||o.saveJson(c,l),this.data=l}comEntry(t){const{option:n,tool:e}=this,{name:s}=n;let o={};let i,r,l;if("cnf"==t){const e=Object.keys(n),s="name|wkd|usd|crd|w|u|c".split("|");i=e.filter((t=>!s.includes(t)))[0],r=n[i],l=i in n,t=l?"add":"get"}else i=n.key,r=n.val,l="val"in n;switch(t){case"add":this.setJsonVal(i,r,l);break;case"del":break;default:o=this.magicReadConfig(s),this.getJsonVal(i,r),h("[info] info data:"),h(o)}return o}};const g=function t(s){return!!n(s)||(t(i(s))?(e(s),!0):void 0)},p=t;function b(t,n={}){let e;try{e=s(t),e=JSON.parse(e)}catch(t){e=n}return e}function m(t,n){o(t,JSON.stringify(n,null,2))}function v(){return process.env["win32"==process.platform?"USERPROFILE":"HOME"]}const{log:y}=console,w={name:".ymcrc.json",wkd:"packages/noop",usd:!1,crd:!0},S=(t={})=>{S.debug&&y("[info] run cmd with: ns"),S.debug&&y("[info] hello ns"),S.debug&&y("[info] log cli option:"),S.debug&&y(t)},$=(t="add")=>(n={})=>{let e;if(S.debug&&y(`[info] run cmd with: ns ${t}`),S.debug&&y(`[info] hello ${t}`),w.wkd="",e=S.notOnlyFlags?{...w,...n.flags}:{...w,...n},S.debug&&y("[info] log now flags:"),S.debug&&y(e),f.option=e,f.tool={parsePath:r,joinPath:l,addDirs:g,delDirs:p,readJson:b,saveJson:m,getUserHome:v},"loc"==t){const t=f.getFileLocList();return y("[info] cnf file list:"),y(t),y("[info] the last file:"),void y(t[t.length-1])}return f.comEntry(t)},C=new class{constructor(){}entrys(t){return t?(this.context=t,this):this.context}bind(t="",n=(()=>{}),e=""){const s=this.entrys();t.split("|").forEach((t=>{let o;if("call"===e.toLowerCase())o=n(t);s[t]=o}))}};C.entrys(S).bind("add|del|put|get",$,"call"),C.entrys(S).bind("loc|cnf",$,"call");const O=((t="ns")=>`cnf gen for ymc repo\n  mgnt cnf file\n  usage:ns [subcmd] [option]\n    ${t} -h\n    ${t} -v\n\n  subns:loc|cnf\n  subcmd:add|del|get\n    add - add des file\n    del - del des file\n    get - get des file\n  option:\n    -n,--name <filename> cnf file name (default:.ymcrc.json )\n    -w,--wkd <dir> set working(packages/libname) dir\n    -u,--usd use user dir\n    -c,--crd use current(project) dir\n    -h,--help get help\n    -v,--version get version\n`)("jcm"),k=((t="npm-bin",n="1.0.0",e="")=>{let s={};return s={...s,version:n,ns:t,autoSubCmd:c("subcmd",e),autoSubNs:c("subns",e)},s})("jcm","1.0.0",O);S.usage=O,S.option=k,S.cnf.enableZeroOption=!0,S.enableZeroOption=!0,S.notOnlyFlags=!0,S.debug=!0;const x=t=>!!["true",!0].includes(t)||!["false",!1].includes(t)&&(Number(t)?Number(t):t),{log:N}=console;const j=new class{constructor(){this.option={helpmsg:"usage:ns option",argvIndexS:2,enbaleSubCmd:!1,subcmd:"",allowAutoSubCmd:!0,autoSubCmd:"",version:"1.0.0",ns:"ycs",enbaleSubNs:!1,subns:"",allowAutoSubNs:!0,autoSubNs:""}}ns(t="ns"){return this.option.ns=t,this}version(t="1.0.0"){return this.option.version=t,this}entry(t={}){return this.option.entrys=t,this}autosubcmd(t=""){return this.option.autoSubCmd=t,this}autosubns(t=""){return this.option.autoSubNs=t,this}nanoparse(t=(()=>{})){return this.option.nanoparse=t,this}run(t){let{entrys:n,helpmsg:e,argvIndexS:s,enbaleSubCmd:o,subcmd:i,allowAutoSubCmd:r,autoSubCmd:l,version:c,ns:a,enbaleSubNs:u,subns:d,allowAutoSubNs:h,autoSubNs:f}=this.option;!u&&h&&f&&(f=Array.isArray(f)?f:f.split("|"),u=f.includes(t[s])),u&&(d=t[s],s++,e=e.replace(/option$/,"subns option")),!o&&r&&l&&(l=Array.isArray(l)?l:l.split("|"),o=l.includes(t[s])),o&&(i=t[s],s++,e=e.replace(/option$/,"subcmd option"));let g=n;if(e=n.usage,u&&d){if(!g[d])return N(`${e}`),void N(`todo:subns:${d}`);e=g[d].usage?g[d].usage:e,c=g[d].version?g[d].version:c,g=g[d]?g[d]:()=>{}}if(o&&i){if(!g[i])return N(`${e}`),void N(`todo:subcmd:${i}`);e=g[i].usage?g[i].usage:e,c=g[i].version?g[i].version:c,g=g[i]?g[i]:()=>{}}let p=t.length<=s;if(n.enableZeroOption&&(p=t.length<s),g.enableZeroOption&&(p=t.length<s),p)return N(`${e}`),void N("error:invalid argv length");const b=function(t){let n=[],e=t;const s=[];t.includes("--")&&(n=t.slice(t.indexOf("--")+1),e=t.slice(0,t.indexOf("--")));const o=[];for(let t=0;t<e.length;t++){const n=e[t-1],i=e[t],r=e[t+1],l=r&&!/^--.+/.test(r)&&!/^-.+/.test(r),c=t=>{o.push([t,!l||r])};if(/^--.+=/.test(i)||/^-.=/.test(i))o.push(i.split("="));else if(/^-[^-].*/.test(i)){let t=i;if(t.includes("=")){const n=t.indexOf("=");o.push([t.slice(n-1,n),t.slice(n+1,n+2)]),t=t.slice(0,n-1)+t.slice(n+2)}for(const n of t.slice(1).split("").slice(0,-1))o.push([n,!0]);c(t[t.length-1])}else if(/^--.+/.test(i)||/^-.+/.test(i))c(i);else{let t=o.find((t=>t[0]===n));if(!t&&/^-./.test(n)){const e=n[n.length-1];t=o.find((t=>t[0]===e))}t||s.push(i)}}const i={};for(const t of o){let n=t[0].replace(/^-{1,2}/g,""),e=t[1];n.startsWith("no-")&&[void 0,!0].includes(e)&&(n=n.slice(3),e=!1),i[n]=x(e)}return{flags:i,_:s.map((t=>x(t))),extras:n.map((t=>x(t)))}}(t.slice(s)),m=b.flags;if((m.debugArgs||m.da)&&N(b),m.version||m.v)N(`${a} version:${c}`);else{if(!m.help&&!m.h)return n.notOnlyFlags||g.notOnlyFlags?g(b):g(m);N(`${e}`)}}};((t={})=>n=>(t.option&&(n.option={...n.option,...t.option}),"version,ns,autoSubCmd,autoSubNs".split(",").forEach((e=>{t[e]&&(n.option[e]=t[e])})),n.entry(t),n))(S)(j),j.run(process.argv);
