/**
  * limitAsyncHandle v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self)["limit-async-handle"]={})}(this,(function(t){"use strict";const{log:e}=console;class s{constructor(t){this.init(t)}init(t){return this._max=t,this._count=0,this._taskQueue=[],this._debug=!1,this._cb=null,this}call(t,...e){return new Promise(((s,i)=>{const n=this._createTask(t,e,s,i);this._count>=this._max?this._taskQueue.push(n):n()}))}_createTask(t,e,s,i){return()=>{t(...e).then(s).catch(i).finally((()=>{this._next()})),this._nextTick()}}_next(){if(this._count-=1,this._taskQueue.length){this._taskQueue.shift()()}else this._debug&&e("task count = ",this._count),this._cb&&this._cb()}_nextTick(){this._count+=1,this._debug&&e("task count = ",this._count)}}const i=new s;t.LimitAsyncHandle=s,t.limitAsyncHandle=i,Object.defineProperty(t,"__esModule",{value:!0})}));
