/**
  * linPkgFile v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("node:child_process"),t=require("node:fs");function n(e){return e.split(/\r?\n/).map((e=>e.trim())).filter((e=>e)).join("\n")}const r=(t,r,o)=>new Promise(((s,i)=>{o||(o=r,r=t,t="");const a=((e,t=" ")=>Array.isArray(e)?e.join(t):e)(r);(o.exec?o.exec:e.exec)(`${t=t?`${t} ${a}`:`${a}`}`,o,((e,t,r)=>{const{fixUnreadbleCode:a}=o;if(a){const{iconvDesEncoding:e,iconvSrcEncoding:n}=o;t&&(t=a(t,e,n)),r&&(r=a(r,e,n))}e&&o.exitWhenErr&&i(e),o.noTrimOut||(t=n(t),r=n(r)),o.rejectStderr&&(r&&i(e),s(t)),s({stdout:t,stderr:r})}))})),o={exec:e.exec};
/**
  * jsonStreamIo v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */
class s{constructor(e,t){this.init(e,t)}async read(e={}){const{file:n}=this;let r,o;try{r=t.createReadStream(n.name),o=await(s=r,new Promise(((e,t)=>{let n="";s.on("data",(e=>{n+=e.toString()})).on("end",(()=>{e(n)})).on("error",t)}))),o=JSON.parse(o)}catch(t){o=e}
/**
  * streamIo v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */
var s;return n.data=o,o}async write(e){const{file:n,option:r}=this;let o,s=e;try{o=t.createWriteStream(n.name),e?n.data=e:s=n.data,await function({stream:e,data:t}){return new Promise(((n,r)=>{e.write(t,"utf-8"),e.end(),e.on("finish",(()=>{n(t)})).on("error",r)}))}({stream:o,data:JSON.stringify(s,null,2)})}catch(e){}}init(e="package.json",t={}){this.file={name:e,data:t},this.option={}}new(...e){return new s(...e)}}const i=new s;const{log:a}=console;function c(e,t="done",n="fail"){let r=n;return e&&(r=t),r}function l(e,t,n,r){return r.some((t=>t.name===e))?r.forEach((r=>{r.name===e&&(r[t]=n)})):r.push({name:e,[`${t}`]:n}),r}exports.exec=r,exports.execOpts=o,exports.getFailOrDone=c,exports.getLibNameFromPath=function(e,t={}){let n=function(e){const t=e.split(/\/?\\|\//);return t[t.length-1]}(e);const r={trim:!0,...t};return r.trim&&(n=n.trim()),r.camelize&&(n=
/**
  * extendString v1.0.0
  * (c) 2018-2022 ymc
  * @license MIT
  */
function(e){return e.replace(/(?:^\w|[A-Z_-]|\b\w)/g,((e,t)=>{let n="";return n=e.replace(/[-_]+/g," "),n=0!==t?n.replace(/[A-Z]/," $&"):n,0===t?n.toUpperCase():n.toLowerCase()})).replace(/\s+/g," ")}(n).replace(/(?:^\w|[A-Z]|\b\w)/g,((e,t)=>0===t?e.toLowerCase():e.toUpperCase())).replace(/\s+/g,"")),n},exports.getPackagesLocFromPath=function(e){return function(e,t="/"){const n=e.split(/\/?\\|\//);return n.slice(0,n.length-1).join(t)}(e)},exports.jsonstream=i,exports.putPkgsInfo=l,exports.runeslint=async function(e,t){a(`[info] run cmd: ${e}`);const{stderr:n,stdout:o}=await r(e,t);let s;return n&&a(n),a(o),s=""===n?"passing":"fail",a(`[info] lint files ${s}`),c(!0,s)},exports.setLinState=async function(e={}){const t={key:"lin_state",state:"todo",storeAt:"pkgs-info.json",...e};let n=t.pkgLoc;a("[info] set lint state in store"),i.init(`${t.pkgLoc}/package.json`);const r=await i.read({});n=t.storeAt,i.init(`${n}`);const o=await i.read([]);l(r.name,t.key,t.state,o),await i.write(o),a(`[info] out: ${n}`)};
