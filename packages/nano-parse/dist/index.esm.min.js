/**
  * nanoParse v0.0.1
  * (c) 2018-2022 ymc
  * @license MIT
  */
function e(e){const t=Array.isArray(e)?e:e.split(/ +/);let i=[],l=t;const n=[];t.includes("--")&&(i=t.slice(t.indexOf("--")+1),l=t.slice(0,t.indexOf("--")));const c=[];for(let e=0;e<l.length;e++){const s=l[e-1],t=l[e],i=l[e+1],f=i&&!/^--.+/.test(i)&&!/^-.+/.test(i),o=e=>{c.push([e,!f||i])};if(/^--.+=/.test(t)||/^-.=/.test(t))c.push(t.split("="));else if(/^-[^-].*/.test(t)){let e=t;if(e.includes("=")){const s=e.indexOf("=");c.push([e.slice(s-1,s),e.slice(s+1,s+2)]),e=e.slice(0,s-1)+e.slice(s+2)}const s=e.slice(1).split("").slice(0,-1);for(const e of s)c.push([e,!0]);o(e[e.length-1])}else if(/^--.+/.test(t)||/^-.+/.test(t))o(t);else{let e=c.find((e=>e[0]===s));if(!e&&/^-./.test(s)){const t=s[s.length-1];e=c.find((e=>e[0]===t))}e||n.push(t)}}const f={};for(const e of c){let t=e[0].replace(/^-{1,2}/g,""),i=e[1];t.startsWith("no-")&&[void 0,!0].includes(i)&&(t=t.slice(3),i=!1),f[t]=s(i)}return{flags:f,_:n.map((e=>s(e))),extras:i.map((e=>s(e)))}}function s(e){return!!["true",!0].includes(e)||!["false",!1].includes(e)&&(Number(e)?Number(e):e)}export{e as default};
