/**
  * nanoParse v0.0.1
  * (c) 2018-2022 ymc
  * @license MIT
  */
function e(e){let t=[],l=e;const i=[];e.includes("--")&&(t=e.slice(e.indexOf("--")+1),l=e.slice(0,e.indexOf("--")));const n=[];for(let e=0;e<l.length;e++){const s=l[e-1],t=l[e],c=l[e+1],f=c&&!/^--.+/.test(c)&&!/^-.+/.test(c),o=e=>{n.push([e,!f||c])};if(/^--.+=/.test(t)||/^-.=/.test(t))n.push(t.split("="));else if(/^-[^-].*/.test(t)){let e=t;if(e.includes("=")){const s=e.indexOf("=");n.push([e.slice(s-1,s),e.slice(s+1,s+2)]),e=e.slice(0,s-1)+e.slice(s+2)}const s=e.slice(1).split("").slice(0,-1);for(const e of s)n.push([e,!0]);o(e[e.length-1])}else if(/^--.+/.test(t)||/^-.+/.test(t))o(t);else{let e=n.find((e=>e[0]===s));if(!e&&/^-./.test(s)){const t=s[s.length-1];e=n.find((e=>e[0]===t))}e||i.push(t)}}const c={};for(const e of n){let t=e[0].replace(/^-{1,2}/g,""),l=e[1];t.startsWith("no-")&&[void 0,!0].includes(l)&&(t=t.slice(3),l=!1),c[t]=s(l)}return{flags:c,_:i.map((e=>s(e))),extras:t.map((e=>s(e)))}}function s(e){return!!["true",!0].includes(e)||!["false",!1].includes(e)&&(Number(e)?Number(e):e)}export{e as default};
