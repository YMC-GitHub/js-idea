/**
  * ycsApi v0.0.2
  * (c) 2018-2022 ymc
  * @license MIT
  */
const s=s=>!!["true",!0].includes(s)||!["false",!1].includes(s)&&(Number(s)?Number(s):s),e=()=>({helpmsg:"usage:ns option",argvIndexS:2,enbaleSubCmd:!1,subcmd:"",allowAutoSubCmd:!0,autoSubCmd:"",version:"1.0.0",ns:"ycs",enbaleSubNs:!1,subns:"",allowAutoSubNs:!0,autoSubNs:""}),t=(s={})=>e=>(s.option&&(e.option={...e.option,...s.option}),"version,ns,autoSubCmd,autoSubNs".split(",").forEach((t=>{s[t]&&(e.option[t]=s[t])})),e.entry(s),e),{log:n}=console;class o{constructor(){this.option={helpmsg:"usage:ns option",argvIndexS:2,enbaleSubCmd:!1,subcmd:"",allowAutoSubCmd:!0,autoSubCmd:"",version:"1.0.0",ns:"ycs",enbaleSubNs:!1,subns:"",allowAutoSubNs:!0,autoSubNs:""}}ns(s="ns"){return this.option.ns=s,this}version(s="1.0.0"){return this.option.version=s,this}entry(s={}){return this.option.entrys=s,this}autosubcmd(s=""){return this.option.autoSubCmd=s,this}autosubns(s=""){return this.option.autoSubNs=s,this}nanoparse(s=(()=>{})){return this.option.nanoparse=s,this}run(e){let{entrys:t,helpmsg:o,argvIndexS:i,enbaleSubCmd:u,subcmd:l,allowAutoSubCmd:r,autoSubCmd:a,version:b,ns:c,enbaleSubNs:p,subns:d,allowAutoSubNs:h,autoSubNs:g}=this.option;!p&&h&&g&&(g=Array.isArray(g)?g:g.split("|"),p=g.includes(e[i])),p&&(d=e[i],i+=1,o=o.replace(/option$/,"subns option")),!u&&r&&a&&(a=Array.isArray(a)?a:a.split("|"),u=a.includes(e[i])),u&&(l=e[i],i+=1,o=o.replace(/option$/,"subcmd option"));let f=t;if(o=t.usage,p&&d){if(!f[d])return n(`${o}`),void n(`todo:subns:${d}`);o=f[d].usage?f[d].usage:o,b=f[d].version?f[d].version:b,f=f[d]?f[d]:()=>{}}if(u&&l){if(!f[l])return n(`${o}`),void n(`todo:subcmd:${l}`);o=f[l].usage?f[l].usage:o,b=f[l].version?f[l].version:b,f=f[l]?f[l]:()=>{}}let S=e.length<=i;if(t.enableZeroOption&&(S=e.length<i),f.enableZeroOption&&(S=e.length<i),S)return n(`${o}`),void n("error:invalid argv length");const m=function(e){let t=[],n=e;const o=[];e.includes("--")&&(t=e.slice(e.indexOf("--")+1),n=e.slice(0,e.indexOf("--")));const i=[];for(let s=0;s<n.length;s++){const e=n[s-1],t=n[s],u=n[s+1],l=u&&!/^--.+/.test(u)&&!/^-.+/.test(u),r=s=>{i.push([s,!l||u])};if(/^--.+=/.test(t)||/^-.=/.test(t))i.push(t.split("="));else if(/^-[^-].*/.test(t)){let s=t;if(s.includes("=")){const e=s.indexOf("=");i.push([s.slice(e-1,e),s.slice(e+1,e+2)]),s=s.slice(0,e-1)+s.slice(e+2)}for(const e of s.slice(1).split("").slice(0,-1))i.push([e,!0]);r(s[s.length-1])}else if(/^--.+/.test(t)||/^-.+/.test(t))r(t);else{let s=i.find((s=>s[0]===e));if(!s&&/^-./.test(e)){const t=e[e.length-1];s=i.find((s=>s[0]===t))}s||o.push(t)}}const u={};for(const e of i){let t=e[0].replace(/^-{1,2}/g,""),n=e[1];t.startsWith("no-")&&[void 0,!0].includes(n)&&(t=t.slice(3),n=!1),u[t]=s(n)}return{flags:u,_:o.map((e=>s(e))),extras:t.map((e=>s(e)))}}(e.slice(i)),v=m.flags;if((v.debugArgs||v.da)&&n(m),v.version||v.v)n(`${c} version:${b}`);else{if(!v.help&&!v.h)return t.notOnlyFlags||f.notOnlyFlags?f(m):f(v);n(`${o}`)}}}export{o as Ycs,e as defOption,t as installEntrys};
