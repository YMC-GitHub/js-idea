/**
  * ycsApi v0.0.2
  * (c) 2018-2022 ymc
  * @license MIT
  */
"use strict";const s=s=>!!["true",!0].includes(s)||!["false",!1].includes(s)&&(Number(s)?Number(s):s),{log:e}=console;module.exports=class{constructor(){this.option={helpmsg:"usage:ns option",argvIndexS:2,enbaleSubCmd:!1,subcmd:"",allowAutoSubCmd:!0,autoSubCmd:"",version:"1.0.0",ns:"ycs",enbaleSubNs:!1,subns:"",allowAutoSubNs:!0,autoSubNs:""}}ns(s="ns"){return this.option.ns=s,this}version(s="1.0.0"){return this.option.version=s,this}entry(s={}){return this.option.entrys=s,this}autosubcmd(s=""){return this.option.autoSubCmd=s,this}autosubns(s=""){return this.option.autoSubNs=s,this}nanoparse(s=(()=>{})){return this.option.nanoparse=s,this}run(t){let{entrys:n,helpmsg:o,argvIndexS:i,enbaleSubCmd:u,subcmd:l,allowAutoSubCmd:r,autoSubCmd:a,version:c,ns:d,enbaleSubNs:p,subns:b,allowAutoSubNs:h,autoSubNs:f}=this.option;!p&&h&&f&&(f=Array.isArray(f)?f:f.split("|"),p=f.includes(t[i])),p&&(b=t[i],i+=1,o=o.replace(/option$/,"subns option")),!u&&r&&a&&(a=Array.isArray(a)?a:a.split("|"),u=a.includes(t[i])),u&&(l=t[i],i+=1,o=o.replace(/option$/,"subcmd option"));let g=n;if(o=n.usage,p&&b){if(!g[b])return e(`${o}`),void e(`todo:subns:${b}`);o=g[b].usage?g[b].usage:o,c=g[b].version?g[b].version:c,g=g[b]?g[b]:()=>{}}if(u&&l){if(!g[l])return e(`${o}`),void e(`todo:subcmd:${l}`);o=g[l].usage?g[l].usage:o,c=g[l].version?g[l].version:c,g=g[l]?g[l]:()=>{}}let m=t.length<=i;if(n.enableZeroOption&&(m=t.length<i),g.enableZeroOption&&(m=t.length<i),m)return e(`${o}`),void e("error:invalid argv length");const v=function(e){let t=[],n=e;const o=[];e.includes("--")&&(t=e.slice(e.indexOf("--")+1),n=e.slice(0,e.indexOf("--")));const i=[];for(let s=0;s<n.length;s++){const e=n[s-1],t=n[s],u=n[s+1],l=u&&!/^--.+/.test(u)&&!/^-.+/.test(u),r=s=>{i.push([s,!l||u])};if(/^--.+=/.test(t)||/^-.=/.test(t))i.push(t.split("="));else if(/^-[^-].*/.test(t)){let s=t;if(s.includes("=")){const e=s.indexOf("=");i.push([s.slice(e-1,e),s.slice(e+1,e+2)]),s=s.slice(0,e-1)+s.slice(e+2)}for(const e of s.slice(1).split("").slice(0,-1))i.push([e,!0]);r(s[s.length-1])}else if(/^--.+/.test(t)||/^-.+/.test(t))r(t);else{let s=i.find((s=>s[0]===e));if(!s&&/^-./.test(e)){const t=e[e.length-1];s=i.find((s=>s[0]===t))}s||o.push(t)}}const u={};for(const e of i){let t=e[0].replace(/^-{1,2}/g,""),n=e[1];t.startsWith("no-")&&[void 0,!0].includes(n)&&(t=t.slice(3),n=!1),u[t]=s(n)}return{flags:u,_:o.map((e=>s(e))),extras:t.map((e=>s(e)))}}(t.slice(i)),S=v.flags;if((S.debugArgs||S.da)&&e(v),S.version||S.v)e(`${d} version:${c}`);else{if(!S.help&&!S.h)return n.notOnlyFlags||g.notOnlyFlags?g(v):g(S);e(`${o}`)}}};
